<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Find the Snake</title>
<style>
  body {
    margin: 0;
    font-family: Arial, sans-serif;
    background: url("https://images.pexels.com/photos/31533982/pexels-photo-31533982.jpeg") no-repeat center center fixed;
    background-size: cover;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding-top: 70px;
    color: white;
    text-align: center;
  }
  h1 { font-size: 2.5em; margin-bottom: 10px; text-shadow: 2px 2px 8px rgba(0,0,0,0.7); }
  #score { background: rgba(0,0,0,0.6); padding: 8px 16px; border-radius: 8px; font-size: 1.2em; margin-bottom: 20px; }
  .game-container { position: relative; display: inline-block; border: 3px solid #fff; border-radius: 12px; overflow: hidden; box-shadow: 0 6px 15px rgba(0,0,0,0.6); }
  #gameImage { max-width: 90vw; max-height: 70vh; border-radius: 12px; cursor: crosshair; display: block; }
  #overlay { position: absolute; top: 0; left: 0; pointer-events: none; }
  #message { margin-top: 15px; font-size: 1.3em; font-weight: bold; text-shadow: 2px 2px 5px rgba(0,0,0,0.7); }
  .controls { margin-top: 20px; }
  button {
    background: #4CAF50;
    color: white;
    border: none;
    padding: 12px 20px;
    margin: 5px;
    font-size: 1em;
    border-radius: 8px;
    cursor: pointer;
    transition: 0.3s;
  }
  button:hover { background: #45a049; }
  #backBtn { background: #ff5252; }
  #skipBtn { background: #ff9800; }
  #gameOverScreen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw; height: 100vh;
    background: rgba(0,0,0,0.4);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 2000;
  }
  #gameOverCard {
    background: white;
    color: black;
    padding: 30px;
    border-radius: 20px;
    text-align: center;
    max-width: 400px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    animation: popIn 0.6s ease;
  }
  @keyframes popIn { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }
  #balloonCanvas {
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    pointer-events: none;
    z-index: 2100;
    display: none;
  }
</style>
</head>
<body>

<h1>üêç Find the Snake!</h1>
<div id="score">Score: 0 / 10</div>

<div class="game-container">
  <img id="gameImage" src="#" alt="Snake Game">
  <canvas id="overlay"></canvas>
</div>

<div id="message"></div>
<div class="controls">
  <button id="backBtn" style="display:none;">‚¨Ö Back</button>
  <button id="skipBtn" style="display:none;">Skip / Show Answer</button>
  <button id="nextBtn" style="display:none;">Next ‚û°</button>
</div>

<canvas id="balloonCanvas"></canvas>

<div id="gameOverScreen">
  <div id="gameOverCard">
    <h2 id="finalTitle">Game Over</h2>
    <p id="finalMessage">Your Score: 0 / 10</p>
    <button class="restartBtn" onclick="restartGame()">üîÑ Play Again</button>
    <button class="infoBtn" onclick="window.location.href='snake-info.html'">üêç Learn About Snakes</button>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
<script>
let userEmail = '';
let startTime = 0;
let balloons = [];

const scriptUrl = "https://script.google.com/macros/s/AKfycbzbTKl3kQr_48fJuKuhPrHiovW2gW-zBupuu_LFL3dHZh62I1LeSKxHdXjWYqCRc1o/exec";

const img = document.getElementById("gameImage");
const message = document.getElementById("message");
const nextBtn = document.getElementById("nextBtn");
const backBtn = document.getElementById("backBtn");
const skipBtn = document.getElementById("skipBtn");
const scoreBox = document.getElementById("score");
const canvas = document.getElementById("overlay");
const ctx = canvas.getContext("2d");
const balloonCanvas = document.getElementById("balloonCanvas");
const bctx = balloonCanvas.getContext("2d");

// Snake rounds with hotspots (assumes snake images are uploaded and paths are correct)
const rounds = [
  { src: "snake2.jpg", hotspot: { type: "circle", x: 695, y: 337, radius: 301 }, solved: false },
  { src: "snake6.jpg", hotspot: { type: "rect", x1: 50, y1: 155, x2: 417, y2: 232 }, solved: false },
  { src: "snake1.jpg", hotspot: { type: "rect", x1: 506, y1: 271, x2: 971, y2: 455 }, solved: false },
  { src: "snake3.jpg", hotspot: { type: "rect", x1: 203, y1: 24, x2: 255, y2: 395 }, solved: false },
  { src: "snake4.jpg", hotspot: { type: "rect", x1: 243, y1: 109, x2: 294, y2: 204 }, solved: false },
  { src: "snake5.jpg", hotspot: { type: "circle", x: 261, y: 171, radius: 29 }, solved: false },
  { src: "snake7.jpeg", hotspot: { type: "circle", x: 1048, y: 2001, radius: 214 }, solved: false },
  { src: "snake10.jpg", hotspot: { type: "rotatedRect", points: [ {x:626,y:466},{x:637,y:509},{x:169,y:735},{x:121,y:666} ] }, solved: false },
  { src: "snake9.jpg", hotspot: { type: "circle", x: 470, y: 1147, radius: 69 }, solved: false },
  { src: "snake8.jpg", hotspot: { type: "rect", x1: 331, y1: 377, x2: 489, y2: 454 }, solved: false }
];

let currentRound = 0;
let score = 0;

// Ask for email before starting
function askEmailAndStart() {
  let email = prompt("Enter your email (@usv.in or @svgcentre.in):");
  if (email && (email.endsWith("@usv.in") || email.endsWith("@svgcentre.in"))) {
    userEmail = email;
    startTime = Date.now();
    loadRound();
  } else {
    alert("Please enter a corporate email ending with @usv.in or @svgcentre.in");
    askEmailAndStart();
  }
}

// JSONP save function
function saveResult(email, score, timeTaken) {
  const callbackName = "jsonp_cb_" + Math.random().toString(36).substr(2,9);
  window[callbackName] = res => {
    console.log("Save result response:", res);
    document.body.removeChild(script);
    delete window[callbackName];
  };
  const script = document.createElement("script");
  script.src = `${scriptUrl}?email=${encodeURIComponent(email)}&score=${score}&timeTaken=${timeTaken}&callback=${callbackName}`;
  document.body.appendChild(script);
}

// Rest of the game logic
function resizeCanvas() { canvas.width = img.clientWidth; canvas.height = img.clientHeight; }
function drawHotspot(h) {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.strokeStyle = "red"; ctx.lineWidth = 3;
  const sx = img.clientWidth / img.naturalWidth;
  const sy = img.clientHeight / img.naturalHeight;
  if (h.type === "circle") {
    ctx.beginPath();
    ctx.arc(h.x * sx, h.y * sy, h.radius * sx, 0, 2 * Math.PI);
    ctx.stroke();
  } else if (h.type === "rect") {
    const x1 = Math.min(h.x1, h.x2) * sx;
    const y1 = Math.min(h.y1, h.y2) * sy;
    ctx.strokeRect(x1, y1, Math.abs(h.x2-h.x1)*sx, Math.abs(h.y2-h.y1)*sy);
  } else if (h.type === "rotatedRect") {
    ctx.beginPath();
    h.points.forEach((p, i) => {
      const px = p.x * sx, py = p.y * sy;
      (i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py));
    });
    ctx.closePath(); ctx.stroke();
  }
}

function pointInPoly(px, py, pts) {
  let inside = false;
  for (let i = 0, j = pts.length - 1; i < pts.length; j = i++) {
    const xi = pts[i].x, yi = pts[i].y,
          xj = pts[j].x, yj = pts[j].y;
    const intersect = ((yi > py) !== (yj > py)) &&
                      (px < (xj - xi) * (py - yi) / (yj - yi) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}

function loadRound() {
  img.src = rounds[currentRound].src;
  message.textContent = "";
  nextBtn.style.display = "none";
  skipBtn.style.display = "inline-block";
  backBtn.style.display = currentRound ? 'inline-block' : 'none';
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if (rounds[currentRound].solved) {
    drawHotspot(rounds[currentRound].hotspot);
    message.textContent = "‚úÖ Already solved!";
    message.style.color = "#76ff03";
    nextBtn.style.display = "inline-block";
    skipBtn.style.display = "none";
  }
}

img.onload = resizeCanvas;

img.addEventListener("click", e => {
  if (rounds[currentRound].solved) return;
  const rect = img.getBoundingClientRect(),
        clickX = (e.clientX - rect.left) * (img.naturalWidth / img.width),
        clickY = (e.clientY - rect.top) * (img.naturalHeight / img.height);
  const h = rounds[currentRound].hotspot;
  let correct = false;

  if (h.type === "circle") {
    const dx = clickX - h.x, dy = clickY - h.y;
    correct = Math.hypot(dx, dy) <= h.radius;
  } else if (h.type === "rect") {
    correct = clickX >= Math.min(h.x1, h.x2) && clickX <= Math.max(h.x1, h.x2)
           && clickY >= Math.min(h.y1, h.y2) && clickY <= Math.max(h.y1, h.y2);
  } else {
    correct = pointInPoly(clickX, clickY, h.points);
  }

  if (correct) {
    rounds[currentRound].solved = true;
    score++;
    scoreBox.textContent = `Score: ${score} / ${rounds.length}`;
    drawHotspot(h);
    message.textContent = "‚úÖ Correct!";
    message.style.color = "#76ff03";
    nextBtn.style.display = "inline-block";
    skipBtn.style.display = "none";
  } else {
    message.textContent = "‚ùå Nope, try again!";
    message.style.color = "#ff5252";
  }
});

skipBtn.addEventListener("click", () => {
  rounds[currentRound].solved = true;
  drawHotspot(rounds[currentRound].hotspot);
  message.textContent = "‚ö†Ô∏è Skipped!";
  message.style.color = "#ffa726";
  nextBtn.style.display = "inline-block";
  skipBtn.style.display = "none";
});

nextBtn.addEventListener("click", () => {
  currentRound++;
  currentRound < rounds.length ? loadRound() : endGame();
});

backBtn.addEventListener("click", () => {
  if (currentRound > 0) {
    if (rounds[currentRound].solved) score--;
    rounds[currentRound].solved = false;
    scoreBox.textContent = `Score: ${score} / ${rounds.length}`;
    currentRound--;
    loadRound();
  }
});

// Balloons & Confetti
function createBalloons(n) {
  balloons = [];
  for (let i = 0; i < n; i++) {
    balloons.push({
      x: Math.random() * balloonCanvas.width,
      y: balloonCanvas.height + Math.random() * 200,
      r: 15 + Math.random() * 20,
      color: `hsl(${Math.random()*360},100%,60%)`,
      speed: 1 + Math.random() * 2
    });
  }
}

function animateBalloons() {
  bctx.clearRect(0,0,balloonCanvas.width,balloonCanvas.height);
  balloons.forEach(b => {
    b.y -= b.speed;
    bctx.beginPath();
    bctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
    bctx.fillStyle = b.color;
    bctx.fill();
  });
  requestAnimationFrame(animateBalloons);
}

function resizeBalloons() {
  balloonCanvas.width = window.innerWidth;
  balloonCanvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeBalloons);
resizeBalloons();

function endGame() {
  const timeTaken = Math.floor((Date.now() - startTime) / 1000);
  document.getElementById("finalMessage").textContent = `Your Score: ${score} / ${rounds.length} ‚Äì Time: ${timeTaken}s`;
  document.getElementById("gameOverScreen").style.display = "flex";
  balloonCanvas.style.display = "block";
  createBalloons(40);
  animateBalloons();
  confetti({ particleCount: 150, spread: 90, origin: { y: 0.7 } });
  saveResult(userEmail, score, timeTaken);
}

function restartGame() {
  currentRound = 0;
  score = 0;
  rounds.forEach(r => r.solved = false);
  scoreBox.textContent = `Score: 0 / ${rounds.length}`;
  document.getElementById("gameOverScreen").style.display = "none";
  balloonCanvas.style.display = "none";
  startTime = Date.now();
  loadRound();
}

// Start the game
askEmailAndStart();
</script>
</body>
</html>
